<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="ja">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta http-equiv="Content-Style-Type" content="text/css">
<meta http-equiv="Content-Script-Type" content="text/javascript">
<meta name="keywords" content="Aoki,Atsushi,Smalltalk,Smalltalker,Program,Programmer,Object,Oriented,Programming">
<meta name="description" content="ソフトウェア工学IIの小テスト">
<meta name="author" content="AOKI Atsushi">
<link rev="made" href="index.html">
<link rel="index" href="index.html">
<style type="text/css">
<!--
body {
  background-color : #ffffff;
  margin : 20px;
  padding : 10px;
  font-family : serif;
  font-size : 10pt;
}
a {
  text-decoration : underline;
  color : #000000;
}
a:link {
  background-color : #ffddbb;
}
a:visited {
  background-color : #ccffcc;
}
a:hover {
  background-color : #dddddd;
}
a:active {
  background-color : #dddddd;
}
div.belt {
  background-color : #eeeeee;
  padding : 0px 4px;
}
div.belt-yellow {
  background-color : #ffffcc;
  padding : 0px 4px;
}
div.belt-blue {
  background-color : #ddeeff;
  padding : 0px 4px;
}
div.right-small {
  text-align : right;
  font-size : 8pt;
}
img.border {
  border-width : 1px;
  border-color : #000000;
  vertical-align : middle;
}
img.borderless {
  border-width : 0px;
  vertical-align : middle;
}
p.belt {
  background-color : #ffeedd;
  padding : 4px 8px;
}
p.belt-blue {
  background-color : #ddeeff;
  padding : 4px 8px;
}
pre.belt {
  background-color : #ddeeff;
  padding : 4px 8px;
}
pre.belt-yellow {
  background-color : #ffffcc;
  padding : 4px 8px;
}
table {
  border-style : solid;
  border-width : 0px;
  border-color : #000000;
  font-family : serif;
  font-size : 10pt;
}
table.profile {
  border-style : solid;
  border-width : 0px;
  border-color : #000000;
  font-family : serif;
  font-size : 10pt;
  margin-top : 8px;
  margin-left : 8px;
  margin-right : 8px;
  margin-bottom : 8px;
}
table.belt {
  border-style : solid;
  border-width : 0px;
  border-color : #000000;
  background-color : #ffeedd;
  padding : 0px 0px;
  width : 100%;
}
table.content {
  border-style : solid;
  border-width : 0px;
  border-color : #000000;
  padding : 2px 4px;
}
table.font-fixed {
  border-style : solid;
  border-width : 0px;
  border-color : #000000;
  padding : 2px 4px;
  font-family : monospace;
}
table.nest {
  border-style : solid;
  border-width : 0px;
  border-color : #000000;
  padding : 0px 0px;
}
td {
  padding : 0px 0px;
  vertical-align : middle;
}
td.center {
  text-align : center;
}
td.center-half {
  text-align : center;
  width : 50%;
  font-size : 8pt;
}
td.center-small {
  text-align : center;
  font-size : 8pt;
  padding : 0px 4px;
}
td.center-small-nopadding {
  text-align : center;
  font-size : 8pt;
  padding : 0px 0px;
}
td.center-white {
  text-align : center;
  background-color : #ffffff;
}
td.center-small-white {
  text-align : center;
  font-size : 8pt;
  background-color : #ffffff;
}
td.center-border1 {
  text-align : center;
  vertical-align : middle;
  empty-cells : show;
  border-style : solid;
  border-width : 1px;
  border-color : #ffc080;
  width : 22px;
  height : 22px;
}
td.left-small {
  text-align : left;
  font-size : 8pt;
  padding : 0px 4px;
}
td.left-small-white {
  text-align : left;
  font-size : 8pt;
  padding : 0px 4px;
  background-color : #ffffff;
}
td.right-small {
  text-align : right;
  font-size : 8pt;
  padding : 0px 4px;
}
td.right-small-white {
  text-align : right;
  font-size : 8pt;
  padding : 0px 4px;
  background-color : #ffffff;
}
th {
  padding : 0px 0px;
  vertical-align : middle;
}
#menu {
  margin: 0px 0px 0px 0px;
  padding: 0px;
  height: 32px;
}
#menu ul {
  margin: 0px;
  padding: 0px;
  list-style: none;
  text-align: center;
  clear: both;
}
#menu li {
  margin: 0px 5px 0px 0px;
  padding: 0px;
  float: left;
}
#menu a {
  display: block;
  padding: 2px 4px;
  text-decoration: none;
  margin: 0px;
  font-weight: bold;
  background: #FFFFFF;
  color: #333333;
  border: 1px solid #666666;
}
#menu a:hover {
  display: block;
  padding: 2px 4px;
  border-bottom: 1px solid #000000;
  text-decoration: none;
  background: #FFCC66;
}
#menu .current {
  background-color: #F45F57;
  font-weight: bold;
  color: #FFFFFF;
  border: 1px solid #333333;
}
-->
</style>
<title>ソフトウェア工学IIの小テスト「樹状整列」プログラム</title>
</head>
<body>
<div id="menu">
<ul>
  <li><a href="../index.html">ホーム</a></li>
  <li><a href="../Requirement/index.html">要求仕様書</a></li>
  <li><a href="../DevelopmentPlan/index.html">開発計画書</a></li>
  <li><a href="../BasicDesign/index.html">基本設計書</a></li>
  <li><a href="../DetailDesign/index.html">詳細設計書</a></li>
  <li><a href="../TestSpecification/index.html">テスト仕様書</a></li>
  <li><a href="../TestResult/index.html">テスト結果</a></li>
  <li><a href="../DevelopmentResult/index.html">開発実績</a></li>
  <li><a href="../Program/index.html" class="current">プログラム</a></li>
  <li><a href="../Manual/index.html">マニュアル</a></li>
</ul>
</div>
<hr>
<h2>ソフトウェア工学IIの小テスト「樹状整列」プログラム</h2>
<ul>
  <li><a href="#Example">Example</a>（メインクラス）</li>
  <li><a href="#Model">Model</a>（モデル）</li>
  <li><a href="#View">View</a>（ビュー）</li>
  <li><a href="#Controller">Controller</a>（コントローラ）</li>
<br>
  <li><a href="#ForestModel">ForestModel</a>（フォレストモデル）</li>
  <li><a href="#ForestView">ForestView</a>（フォレストビュー）</li>
  <li><a href="#ForestController">ForestController</a>（フォレストコントローラー）</li>
  <li><a href="#ForestNode">ForestNode</a>（フォレストノード）</li>
<br>
  <li><a href="#ForestNodeController">ForestNodeController</a>（フォレストノードコントローラー）</li>
  <li><a href="#Constants">Constants</a>（コンスタンツ）</li>
 <ul>
 <br>
   <li><a href="#Forest.mf">Forest.mf</a>（マニフェストファイル）</li>
   <li><a href="#Makefile">Makefile</a>（メイクファイル）</li>
   <li><a href="#build.xml">build.xml</a>（ビルドファイル）</li>
 </ul>
</ul>
<div class="belt"><h3><a name="Example">Example（メインクラス）</a></h3></div>
<pre>


</pre>
<div class="belt"><h3><a name="Model">Model（モデル）</a></h3></div>
<pre>package forest;


import java.util.ArrayList;
import java.io.File;
import java.io.FileReader;
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.awt.Color;
import java.awt.Point;
import java.awt.Dimension;
import javax.swing.JFrame;
import javax.swing.JLabel;


public class ForestModel extends mvc.Model
{

  /**
   * ノードの集合
   */
  private ArrayList<ForestNode> forestNodes;

  private Point offset;

  private Point oldOffset;

  public ForestModel(File aFile)
  {
    super();
    forestNodes = new ArrayList<ForestNode>();
    offset = new Point(0, 0);
    oldOffset = new Point(0, 0);
    this.createNodes(aFile);
    this.open(aFile.getName());
    this.perform();
  }

  public void open(String aFileName)
  {
    ForestView aView = new ForestView(this);
    JFrame aWindow = new JFrame(aFileName);
    aView.setLayout(null);

    aWindow.getContentPane().add(aView);
    aWindow.setMinimumSize(new Dimension(400, 300));
    aWindow.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    aWindow.setSize(800, 600);
    aWindow.setVisible(true);

    int aNodeX = 0, aNodeY = Constants.VERTICAL_INTERVAL;
    for (ForestNode aNode : forestNodes)
      {
        aNode.moveTo(aNodeX, aNodeY);
        JLabel aLabel = aNode.getLabel();
        aView.add(aLabel);
        aNodeY += aLabel.getHeight() + Constants.VERTICAL_INTERVAL;
      }
    return;
  }

  /**
   * ファイルの名前からノードの集合を作成する。
   */
  public void createNodes(File aFile)
  {
    try
      {
        FileReader aFileReader = new FileReader(aFile);
        BufferedReader aBufferedReader = new BufferedReader(aFileReader);
        String aLine;
        while ((aLine = aBufferedReader.readLine()) != null)
          {
            if (aLine.equals("nodes:"))
              {
                String[] anElement;
                while (!(aLine = aBufferedReader.readLine()).equals("branches:"))
                  {
                    anElement = aLine.split(", ");
                    ForestNode aNode = new ForestNode(anElement[1]);
                    this.addForestNode(aNode);
                  }
              }
            if (aLine.equals("branches:"))
              {
                String[] indexes;
                int parentIndex, childIndex;
                ForestNode aParent, aChild;
                while ((aLine = aBufferedReader.readLine()) != null)
                  {
                    indexes = aLine.split(", ");
                    parentIndex = Integer.parseInt(indexes[0]) - 1;
                    childIndex = Integer.parseInt(indexes[1]) - 1;

                    aParent = this.getForestNode(parentIndex);
                    aChild = this.getForestNode(childIndex);

                    aParent.addChild(childIndex, aChild);
                    aChild.addParent(aParent);
                  }
              }
          }
            
        aBufferedReader.close();
        aFileReader.close();
      }
    catch (FileNotFoundException anException)
      {
        System.out.println(anException);
      }
    catch (IOException anException)
      {
        System.out.println(anException);
      }
    
    int rootDepth = 0;
    for (ForestNode aNode : forestNodes)
      {
        if (aNode.isRoot())
          {
            aNode.recursiveInitRows();
            aNode.recursiveInitDepth(rootDepth);
          }
      }
    return;
  }

  public void perform()
  {
    int rootRows = 0;
    for (ForestNode aNode : forestNodes)
      {
        if (aNode.isRoot())
          {
            this.recursiveNodeAligning(rootRows, aNode);
            rootRows += aNode.getRows();
          }
      }
    return;
  }

  public void recursiveNodeAligning(int line, ForestNode aNode)
  {
    double aNodeX, aNodeY;
    JLabel aLabel;
    aLabel = aNode.getLabel();
    if (!aNode.isRoot())
      {
        JLabel aParentLabel;
        aParentLabel = aNode.getParent().getLabel();
        aNodeX = aParentLabel.getX() + aParentLabel.getWidth() + Constants.HORIZONTAL_INTERVAL;
        aNodeY = aParentLabel.getY() + aParentLabel.getHeight() * line + line * Constants.VERTICAL_INTERVAL;
      }
    else
      {
        aNodeX = aLabel.getX();
        aNodeY = line * aLabel.getHeight() + line * Constants.VERTICAL_INTERVAL - offset.y;
      }
    aNode.moveTo((int) aNodeX, (int) aNodeY);
    this.changed();
    try
      {
        Thread.sleep(50);
      }
    catch (InterruptedException anException)
      {
        System.err.println(anException);
        throw new RuntimeException(anException.toString());
      }

    int childLine = 0;
    for (ForestNode aChild : aNode.getChildren().values())
      {
        if (aChild.getParent().equals(aNode))
          {
            this.recursiveNodeAligning(childLine, aChild);
            childLine += aChild.getRows() - 1;
            childLine++;
          }
      }
    
    aNodeX = aLabel.getX();
    if ((aNode.getRows() % 2) == 0)
      {
        aNodeY = aLabel.getY() + (aNode.getRows() / 2 - 0.5) * aLabel.getHeight() + aNode.getRows() / 2;
      }
    else
      {
        aNodeY = aLabel.getY() + (aNode.getRows() / 2) * aLabel.getHeight() + aNode.getRows() / 2;
      }
    aNode.moveTo((int) aNodeX, (int) aNodeY);
    this.changed();
    try
      {
        Thread.sleep(50);
      }
    catch (InterruptedException anException)
      {
        System.err.println(anException);
        throw new RuntimeException(anException.toString());
      }

    return;
  }

  public void scrollNodes(Point aPoint)
  {
    offset = aPoint;
    if (!offset.equals(oldOffset))
      {
        for (ForestNode aNode : forestNodes)
          {
            Point nodePoint = aNode.getLabel().getLocation();
            nodePoint.translate(-offset.x + oldOffset.x, -offset.y + oldOffset.y);
            aNode.getLabel().setLocation(nodePoint);
          }
      }
    oldOffset = new Point(offset);
  }

  /**
   * ノードの集合の最後にノードを追加する。
   */
  public void addForestNode(ForestNode aNode)
  {
    forestNodes.add(aNode);
    return;
  }

  /**
   * インデックスで指定されたノードを返す。
   */
  public ForestNode getForestNode(int anIndex)
  {
    ForestNode aNode = forestNodes.get(anIndex);
    return aNode;
  }

  /**
   * ノードの集合を返す。
   */
  public ArrayList<ForestNode> getForestNodes()
  {
    return forestNodes;
  }

}
	 * 指定されたビューを依存物に設定する。
	 * 良好（2010年7月25日）
	 */
	public void addDependent(View aView)
	{
		dependents.add(aView);
		return;
	}
	
	/**
	 * モデルの内部状態が変化していたので、自分の依存物へupdateのメッセージを送信する。
	 * 良好（2010年7月25日）
	 */
	public void changed()
	{
		Iterator anIterator = dependents.iterator();
		while (anIterator.hasNext())
		{
			View aView = (View)anIterator.next();
			aView.update();
		}
		return;
	}
	
	/**
	 * 初期化する。
	 * 良好（2010年7月25日）
	 */
	private void initialize()
	{
		dependents = new ArrayList<View>();
		picture = null;
		return;
	}
		
	/**
	 * 何もしない。
	 * 良好（2010年7月25日）
	 */
	public void perform()
	{
		return;
	}
	
	/**
	 * 画像（モデルの内容物）を応答する。
	 * 良好（2010年7月25日）
	 */
	public BufferedImage picture()
	{
		return picture;
	}
		
	/**
	 * 画像（モデルの内容物）を設定する。
	 * 良好（2010年7月25日）
	 */
	public void picture(BufferedImage anImage)
	{
		picture = anImage;
		return;
	}
	
	/**
	 * このインスタンスを文字列にして応答する。
	 * 良好（2010年7月25日）
	 */
	public String toString()
	{
		StringBuffer aBuffer = new StringBuffer();
		Class aClass = this.getClass();
		aBuffer.append(aClass.getName());
		aBuffer.append("[picture=");
		aBuffer.append(picture);
		aBuffer.append("]");
		return aBuffer.toString();
	}
}</pre>
<div class="belt"><h3><a name="View">View（ビュー）</a></h3></div>
<pre>package mvc;

import java.awt.Point;
import java.awt.Graphics;
import java.awt.image.BufferedImage;
import javax.swing.JPanel;
import java.awt.Color;

/**
 * ビュー。
 */
public class View extends JPanel
{
	/**
	 * 情報を握っているModelのインスタンスを束縛する。
	 * 束縛されるModelのインスタンスはpicture()というメッセージに応答できなければならない。
	 * 良好（2010年7月25日）
	 */
	protected Model model;

	/**
	 * 制御を司るControllerのインスタンスを束縛する。
	 * 良好（2010年7月25日）
	 */
	protected Controller controller;
	
	/**
	 * スクロール量としてPointのインスタンスを束縛する。
	 * 良好（2010年7月25日）
	 */
	private Point offset;

	/**
	 * インスタンスを生成して応答する。
	 * 指定されたモデルの依存物となり、コントローラを作り、モデルとビューを設定し、スクロール量を(0, 0)に設定する。
	 * 良好（2010年7月25日）
	 */
	public View(Model aModel)
	{
		super();
		model = aModel;
		model.addDependent(this);
		controller = new Controller();
		controller.setModel(model);
		controller.setView(this);
		offset = new Point(0, 0);
	}

	/**
	 * インスタンスを生成して応答する。
	 * 指定されたモデルの依存物となり、指定されたコントローラにモデルとビューを設定し、スクロール量を(0, 0)に設定する。
	 * 良好（2010年7月25日）
	 */
	public View(Model aModel, Controller aController)
	{
		super();
		model = aModel;
		model.addDependent(this);
		controller = aController;
		controller.setModel(model);
		controller.setView(this);
		offset = new Point(0, 0);
	}
	
	/**
	 * 指定されたグラフィクスに背景色（灰色）でビュー全体を塗り、その後にモデルの内容物を描画する。
	 * それはスクロール量（offset）を考慮してモデル画像（picture）をペイン（パネル）内に描画することである。
	 * 良好（2010年7月25日）
	 */
	public void paintComponent(Graphics aGraphics)
	{
		int width = this.getWidth();
		int height = this.getHeight();
		aGraphics.setColor(Color.gray);
		aGraphics.fillRect(0, 0, width, height);
		if (model == null) { return; }
		BufferedImage picture = model.picture();
		if (picture == null) { return; }
		aGraphics.drawImage(picture, offset.x, offset.y, null);
		return;
	}

	/**
	 * スクロール量（offsetの逆向きの大きさ）を応答する。
	 * 良好（2010年7月25日）
	 */
	public Point scrollAmount()
	{
		int x = 0 - offset.x;
		int y = 0 - offset.y;
		return (new Point(x, y));
	}
	
	/**
	 * スクロール量を指定された座標分だけ相対スクロールする。
	 * 良好（2010年7月25日）
	 */
	public void scrollBy(Point aPoint)
	{
		int x = offset.x + aPoint.x;
		int y = offset.y + aPoint.y;
		this.scrollTo(new Point(x, y));
		return;
	}

	/**
	 * スクロール量を指定された座標に設定（絶対スクロール）する。
	 * 良好（2010年7月25日）
	 */
	public void scrollTo(Point aPoint)
	{
		offset = aPoint;
		return;
	}

	/**
	 * このインスタンスを文字列にして応答する。
	 * 良好（2010年7月25日）
	 */
	public String toString()
	{
		StringBuffer aBuffer = new StringBuffer();
		Class aClass = this.getClass();
		aBuffer.append(aClass.getName());
		aBuffer.append("[model=");
		aBuffer.append(model);
		aBuffer.append(",offset=");
		aBuffer.append(offset);
		aBuffer.append("]");
		return aBuffer.toString();
	}
	
	/**
	 * ビューの全領域を再描画する。
	 * 良好（2010年7月25日）
	 */
	public void update()
	{
		this.repaint(0, 0, this.getWidth(), this.getHeight());
		return;
	}
}</pre>
<div class="belt"><h3><a name="Controller">Controller（コントローラ）</a></h3></div>
<pre>package mvc;

import java.awt.Component;
import java.awt.Cursor;
import java.awt.Point;
import java.awt.event.MouseEvent;
import java.awt.event.MouseWheelEvent;
import java.awt.event.MouseWheelListener;
import javax.swing.event.MouseInputAdapter;

/**
 * コントローラ。
 */
public class Controller extends MouseInputAdapter implements MouseWheelListener
{
	/**
	 * 情報を握っているModelのインスタンスを束縛する。
	 * 良好（2010年7月25日）
	 */
	protected Model model;
	
	/**
	 * 表示を司るViewのインスタンスを束縛する。
	 * 良好（2010年7月25日）
	 */
	protected View view;
	
	/**
	 * 以前にマウスのボタンが押下された場所をPointのインスタンスとして束縛する。
	 * 良好（2010年7月25日）
	 */
	private Point previous;
	
	/**
	 * 現在にマウスのボタンが押下された場所をPointのインスタンスとして束縛する。
	 * 良好（2010年7月25日）
	 */
	private Point current;

	/**
	 * インスタンスを生成して応答する。
	 * すべてのインスタンス変数（model, view, previous, current）をnull化する。
	 * 良好（2010年7月25日）
	 */
	public Controller()
	{
		super();
		model = null;
		view = null;
		previous = null;
		current = null;
	}

	/**
	 * 指定されたマウスイベントからマウスカーサの位置を獲得して、モデル座標系でのクリック位置を割り出して標準出力に出力する。
	 * 良好（2010年7月25日）
	 */
	public void mouseClicked(MouseEvent aMouseEvent)
	{
		Point aPoint = aMouseEvent.getPoint();
		aPoint.translate(view.scrollAmount().x, view.scrollAmount().y);
		System.out.println(aPoint);
		return;
	}

	/**
	 * マウスカーサの形状を移動の形に変化させ、指定されたマウスイベントからマウスカーサの位置を獲得して、
	 * インスタンス変数currentに設定すると共に、以前のマウスカーサの位置からの差分を計算する。
	 * そして、その差分だけビューに対してスクロールを依頼し、その後にビューの再描画を依頼する。
	 * 最後にインスタンス変数previousをインスタンス変数currentに更新する。
	 * 良好（2010年7月25日）
	 */
	public void mouseDragged(MouseEvent aMouseEvent)
	{
		Cursor aCursor = Cursor.getPredefinedCursor(Cursor.MOVE_CURSOR);
		Component aComponent = (Component)aMouseEvent.getSource();
		aComponent.setCursor(aCursor);
		current = aMouseEvent.getPoint();
		int x = current.x - previous.x;
		int y = current.y - previous.y;
		Point point = new Point(x, y);
		view.scrollBy(point);
		view.repaint();
		previous = current;
		return;
	}

	/**
	 * 何もしない。
	 * 良好（2010年7月25日）
	 */
	public void mouseEntered(MouseEvent aMouseEvent)
	{
		return;
	}

	/**
	 * 何もしない。
	 * 良好（2010年7月25日）
	 */
	public void mouseExited(MouseEvent aMouseEvent)
	{
		return;
	}

	/**
	 * 何もしない。
	 * 良好（2010年7月25日）
	 */
	public void mouseMoved(MouseEvent aMouseEvent)
	{
		return;
	}

	/**
	 * マウスカーサの形状を十字に変化させ、指定されたマウスイベントからマウスカーサの位置を獲得して、
	 * インスタンス変数currentに設定する共にインスタンス変数previousをインスタンス変数currentに更新する。
	 * 良好（2010年7月25日）
	 */
	public void mousePressed(MouseEvent aMouseEvent)
	{
		Cursor aCursor = Cursor.getPredefinedCursor(Cursor.CROSSHAIR_CURSOR);
		Component aComponent = (Component)aMouseEvent.getSource();
		aComponent.setCursor(aCursor);
		current = aMouseEvent.getPoint();
		previous = current;
		return;
	}

	/**
	 * マウスカーサの形状をデフォルトに戻し、指定されたマウスイベントからマウスカーサの位置を獲得して、
	 * インスタンス変数currentに設定する共にインスタンス変数previousをインスタンス変数currentに更新する。
	 * 良好（2010年7月25日）
	 */
	public void mouseReleased(MouseEvent aMouseEvent)
	{
		Cursor aCursor = Cursor.getDefaultCursor();
		Component aComponent = (Component)aMouseEvent.getSource();
		aComponent.setCursor(aCursor);
		current = aMouseEvent.getPoint();
		previous = current;
		return;
	}

	/**
	 * 何もしない。
	 * 良好（2010年7月25日）
	 */
	public void mouseWheelMoved(MouseWheelEvent aMouseWheelEvent)
	{
		return;
	}

	/**
	 * 指定されたモデルをインスタンス変数modelに設定する。
	 * 良好（2010年7月25日）
	 */
	public void setModel(Model aModel)
	{
		model = aModel;
		return;
	}

	/**
	 * 指定されたビューをインスタンス変数viewに設定し、ビューのマウスのリスナおよびモーションリスナそしてホイールリスナをこのコントローラにする。
	 * 良好（2010年7月25日）
	 */
	public void setView(View aView)
	{
		view = aView;
		view.addMouseListener(this);
		view.addMouseMotionListener(this);
		view.addMouseWheelListener(this);
		return;
	}
	
	/**
	 * このインスタンスを文字列にして応答する。
	 * 良好（2010年7月25日）
	 */
	public String toString()
	{
		StringBuffer aBuffer = new StringBuffer();
		Class aClass = this.getClass();
		aBuffer.append(aClass.getName());
		aBuffer.append("[model=");
		aBuffer.append(model);
		aBuffer.append(",view=");
		aBuffer.append(view);
		aBuffer.append("]");
		return aBuffer.toString();
	}
}</pre>
<div class="belt"><h3><a name="ForestModel">ForestModel（フォレストモデル）</a></h3></div>
<pre>





</pre>
<div class="belt"><h3><a name="ForestView">ForestView（フォレストビュー）</a></h3></div>
<pre>




</pre>
<div class="belt"><h3><a name="ForestController">ForestController（フォレストコントローラー）</a></h3></div>
<pre>



</pre>
<div class="belt"><h3><a name="ForestNode">ForestNode（フォレストノード）</a></h3></div>
<pre>



</pre>
<div class="belt"><h3><a name="ForestNodeController">ForestNodeController（フォレストノードコントローラー）</a></h3></div>
<pre>



</pre>
<div class="belt"><h3><a name="Constants">Constants（コンスタンツ）</a></h3></div>
<pre>









</pre>
<div class="belt"><h3><a name="Forest.mf">Forest.mf（マニフェストファイル）</a></h3></div>
<pre>Manifest-Version: 1.0
Main-Class: forest.Example</pre>
<div class="belt"><h3><a name="Makefile">Makefile（メイクファイル）</a></h3></div>
<pre>ANT	= env LC_ALL=ja_JP.UTF-8 ant

all:
	$(ANT) all

clean:
	$(ANT) clean

test:
	$(ANT) test

install:
	$(ANT) install

doc:
	$(ANT) doc

zip:
	$(ANT) zip</pre>
<div class="belt"><h3><a name="build.xml">build.xml（ビルドファイル）</a></h3></div>
<a href="Forest/build.xml">buildファイル</a>
<hr>
<div class="right-small">Copyright 2013 Project Forest, Updated: 2013/07/25 (Created: 2013/07/23)</div>
</body>
</html>
